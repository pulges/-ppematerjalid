<!DOCTYPE html>
<html>
<head>
<title>index.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///home/oliver/Sites/-ppematerjalid/Darkdown.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="sissejuhatus-redux-saga-kasutamisse">Sissejuhatus redux-saga kasutamisse</h1>
<h2 id="%C3%BCldine-react-redux-rakenduse-skeem">Üldine React-redux rakenduse skeem</h2>
<pre><code class="language-mermaid"><div class="mermaid">flowchart LR

subgraph Store
  Reducers
end

Store --> | connect | View
View --> |event| Action[Action or Dispatch]

Action --> Middleware[MIDDLEWARE\nSome async method\ncapable of reading current store and\nsending updates to state ]

Middleware --> |request| APIs
APIs --> |response| Middleware

Middleware --> Reducers
</div></code></pre>
<h2 id="store">STORE:</h2>
<p>Kogu rakenduse ülene javascripti objekt, mis peaks kajastama kogu rakenduse hetke andmeid / sruktuuri jne. Kõik muudatused <code>store</code>le peavad olema immutable ehk <code>old_prop !== new_prop</code> ja <code>old_store !== new_store</code>.</p>
<h2 id="view">View:</h2>
<p>Reactis vaadet renderdav klass või meetod, mis üldjuhul seob ennast mõnede stores leiduvate väärtuste külge kasutades <code>connect()</code> meetodit või saab propsid otse parameetritena sisse. Ideaalis peaks stores sisalduv 1:1 kirjeldama ära kogu vaate. Praktikas on vahest mõistlik kasutada sisemist <code>state</code> objekti lisaks, aga pigem hoiduda kui saab. View (React.PureComponent) teab ennast renderdada kui mõni proppidest vastab tingimusele <code>old !== new</code>.</p>
<h2 id="action-or-dispatch">Action or Dispatch:</h2>
<p>Kui kasutaja teeb Viewl mingi eventi, nagu klikib või sisestab tähe, siis selle tulemusel kutsub View välja olenevalt middleware valikust:</p>
<ul>
<li>Redux thunk - Action meetodi (mille sees omakorda asynk thunk meetod)</li>
<li>Redux-saga - Dispatch meetodi, mis ei pea <code>store</code> muudatust otse välja kutsuma vaid võib ka olla lihtsalt teavitus eventiks sagadele, et kasutaja tegi midagi.</li>
</ul>
<h2 id="middleware">MIDDLEWARE:</h2>
<h3 id="redux-thunk">Redux-thunk</h3>
<p>Hetkel on meil kasutusel Redux thunk, mis pakib Action meetodi ümber omakorda meetodi väljakutsumise, millele antakse kaasa parameetritena meetodid:</p>
<ul>
<li><code>getState()</code> - tagastab hetkel kehtiva store</li>
<li><code>dispatch()</code> - võimaldab välja kutsuda store muutmise meetodeid (reducer)</li>
</ul>
<p>View:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>{
  handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> { userId, fetchUser } = <span class="hljs-keyword">this</span>.props;
    fetchUser(userid);
  }

  render() {
    &lt;button onClick={ <span class="hljs-keyword">this</span>.handleClick }&gt;
      Fetch user info
    &lt;<span class="hljs-regexp">/button&gt;
  }
}
const mapDispatchToProps = dispatch =&gt; bindActionCreators({ fetchUser }, dispatch);
export default connect(undefined, mapDispatchToProps)(MyView);
</span></div></code></pre>
<p>Action-thunk:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUser</span>(<span class="hljs-params">id</span>) </span>{

  <span class="hljs-comment">// The async capable method</span>
  <span class="hljs-comment">// capable of reading current store</span>
  <span class="hljs-comment">// and sending updates to state</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch, getState) =&gt; {

    <span class="hljs-comment">// Reading current store</span>
    <span class="hljs-keyword">const</span> state = getsSate();

    <span class="hljs-keyword">if</span> (state.user.id !== id) {

      <span class="hljs-comment">// Communicating with api asynchronously</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> ajax(<span class="hljs-string">'GET'</span>, <span class="hljs-string">`/user/<span class="hljs-subst">${ id }</span>`</span>):
      } <span class="hljs-keyword">catch</span>() {
        <span class="hljs-comment">// calling reducer to update state to notify error</span>
        dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_USER_FETCH_ERROR'</span>, <span class="hljs-attr">userId</span>: id });
      }

      <span class="hljs-comment">// calling reducer to update state</span>
      dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_USER'</span>, user });

    }
  }
}
</div></code></pre>
<h3 id="redux-saga">Redux-saga</h3>
<p>Redux-Saga loogika järgi kasutaja event tagajärjel kutsutakse välja <code>dispatch()</code> meetod. See on justkui globaalne event
rakenduse storel, mis teavitab, et midagi juhtus/tehti.
Saga võimekus kõikki store evente kuulata ja selle tagakärjel käivitauda.</p>
<p>View:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>{
  handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> { userId, dispatch } = <span class="hljs-keyword">this</span>.props;
    dispatch({
      <span class="hljs-attr">type</span>: <span class="hljs-string">'USER_CLICKED_FETCH_INFO'</span>,
      <span class="hljs-attr">userId</span>: userId
    });
  }

  render() {
    &lt;button onClick={ <span class="hljs-keyword">this</span>.handleClick }&gt;
      Fetch user info
    &lt;<span class="hljs-regexp">/button&gt;
  }
}
const mapDispatchToProps = dispatch =&gt; ({ dispatch });
export default connect(undefined, mapDispatchToProps)(MyView);
</span></div></code></pre>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchUserInfo</span>(<span class="hljs-params">action</span>) </span>{
  <span class="hljs-keyword">const</span> { userId } = action;

  <span class="hljs-comment">// Reading reading current store state</span>
  <span class="hljs-keyword">const</span> currentState = <span class="hljs-keyword">yield</span> select();

  <span class="hljs-keyword">if</span> (state.user.id !== userId) {

    <span class="hljs-comment">// Communicating with api asynchronously</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">yield</span> ajax(<span class="hljs-string">'GET'</span>, <span class="hljs-string">`/user/<span class="hljs-subst">${ userId }</span>`</span>);
    } <span class="hljs-keyword">catch</span>() {
      <span class="hljs-comment">// calling reducer to update state to notify error</span>
      <span class="hljs-keyword">yield</span> put({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_USER_FETCH_ERROR'</span>, <span class="hljs-attr">userId</span>: userId });
    }

    <span class="hljs-comment">// calling reducer to update state</span>
    <span class="hljs-keyword">yield</span> put({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_USER'</span>, user });
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">userSaga</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> all([
    takeLatest([ <span class="hljs-string">'USER_CLICKED_FETCH_INFO'</span> ], fetchUserInfo),
  ]);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> initializeApp;
</div></code></pre>
<p>Üldpildis on saga meetod sisult samasugune kui thunk asünk meetod aga selliste asendustega:</p>
<ul>
<li><code>dispatch()</code> -&gt; <code>yield put()</code></li>
<li><code>getState()</code> -&gt; <code>yeild select()</code></li>
<li><code>await</code> -&gt; <code>yield</code></li>
</ul>
<h1 id="k%C3%BCsimus-miks-kolida-saga-generaator-funktsioonidele">Küsimus: miks kolida saga-generaator funktsioonidele?</h1>
<p>Kui pea ainuke vahe tundub olema asynk funktsiooni asendamine saga wrapitud generaator funktsiooniga, siis miks? Mis kasu see toob?
Probleem seisneb selles, et asynk funktsioonil pole mingit sisemist võimekust ennast peatada kui ta käima on lastud.
Ehk kui süütad, siis põleb lõpuni.</p>
<p>Redux-Saga kasutab js generaator funktsioone, et sisuliselt taasluua
asynk funktsioonide funktsionaalsus aga koos võimekusega:</p>
<ul>
<li>Katkestada koodi käivitumine asünkroonsete ettappide vahel</li>
<li>Propageerida see katkestamine ka sisemistele generaator funktsioonidele</li>
<li>Anda võimekus igale generaator funktsioonile teha koristustöid juhul kui ta katsekstatakse</li>
</ul>
<p>Lisaks Pakub Redux saga:</p>
<ul>
<li>Mitmes kohas sama sündmuse peale millegi tegemise (parem eristatus koodi osade vahel - iga kood saab paremine vastutada ainult enda eest)</li>
<li>Meetodid protsesside jälgimiseks ja katkestamiseks (eventide race, viimane jääb peale, mõne muu protsessi algus katkestab käimasoleva, jne)</li>
<li>Lihtsamat viisi kirjutada unit-teste kui oli asynk meetodite puhul (ka lihtsam ajax fetch mockimine) https://redux-saga.js.org/docs/advanced/Testing</li>
</ul>
<h3 id="puudused">Puudused:</h3>
<ul>
<li>
<p>Kahjuks tuleb kaasa ka tavaline event based süsteemide puudus,
et on keerulisem jälgida kas eventi peale keegi midagi ka tegi ja ka taguspidi, et kes selle eventi saatis.
Siin aitab ainult ühtne kokkulepitud struktuur, koodi puhtus ja <em>common sense</em>. Esimene neist kusjuures kõige olulisem.</p>
</li>
<li>
<p>asynk meetodied saga generaatori sees on üpris lihtne kasutada. Asenda  <code>await</code> -&gt; <code>yield</code>. Tagurpidi aga
on vaja mingi kaval wrapper ehitada ja keerulisem märgatavalt.</p>
</li>
<li>
<p>Typescript ei ole väga hästi generaator funktsioonide sellisele kasutusele (kus vaheväärtusi justkui ei kasutata)
järgi jõudnud ja arvan, et lähiajal ei jõua ka (Erinevate keelemaailmade konflikt Typescript arendajate peas).
Seega Typescript tihti kipub mikrofoni nurka viskama ja nõuab, et arendaja ütleks käsitsi, mis tüüp generaatorist
välja tuli.</p>
</li>
</ul>
<h2 id="l%C3%BChidalt-function">Lühidalt <code>function*</code></h2>
<p>Sisuliselt selline spetsiaalne funktsioon, mis iga kord next() küsides tagastab järgmise talle antud yield väärtuse.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">anotherGenerator</span>(<span class="hljs-params">i</span>) </span>{
  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">3</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params">i</span>) </span>{
  <span class="hljs-keyword">yield</span> i;
  <span class="hljs-keyword">yield</span>* anotherGenerator(i);
  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">10</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-string">"END"</span>;
}

<span class="hljs-keyword">var</span> gen = generator(<span class="hljs-number">10</span>);

<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 11</span>
<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 12</span>
<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 13</span>

<span class="hljs-built_in">console</span>.log(gen.next()); <span class="hljs-comment">// { value: 20, done: false }</span>
<span class="hljs-built_in">console</span>.log(gen.next()); <span class="hljs-comment">// { value: "END", done: true }</span>
<span class="hljs-built_in">console</span>.log(gen.next()); <span class="hljs-comment">// { value: undefined, done: true }</span>

</div></code></pre>
<p>Ehk justkui ei midagi maagilist ja pea kogu võimekkus, millest enne oli jutt, tuleneb saga meetoditest mis pannakse
nende generaator funktsioonide ümber.</p>
<h1 id="saga-efektidmeetodid">Saga efektid/meetodid</h1>
<p>Lihtsustatud kirjeldus on et Sagade seos Middlewarena ja ka effektid sisuliselt kutsuvad koguaeg välja next() kuni
pole öeldud et on katkestatud.</p>
<h3 id="peamised-meetodid">Peamised meetodid:</h3>
<ul>
<li>
<p><code>select()</code> - tagastab küsimise hetkel kogu store state.</p>
</li>
<li>
<p><code>put({ type: 'EVENT', data: data })</code> - kutsub välja redux <code>dispatch()</code> meetodi</p>
</li>
<li>
<p><code>take('EVENT')</code> - ootab kuni juhtub event</p>
</li>
<li>
<p><code>call(generaatorF)</code> - kutsu välja teine generaator</p>
</li>
<li>
<p><code>all[generatorF, generatorF, generatorF, ...]</code> - jooksuta saagasid (generaatorid) paralleelselt.</p>
<ul>
<li>Protsessid jooksevad paralleelselt, aga jäävad väljakutsuva generaatoriga seotuks. Ehk kui parent generaatorile
kutsutakse välja katkestus, siis samal hetkel saavad ka kõik alamgeneraatorid ja nende alamgeneraatorid katkestatud.</li>
<li>Sagades on sama meetodi analoog meetod <code>fork(generaatorF)</code> - Spekis mõiste: <em>attached fork</em></li>
</ul>
</li>
<li>
<p><code>spawn(generatorF)</code> - kutsu välja teine generaaator, aga ära oota tulemust ja kui parent katkestatakse, siis kutsutud
meetodit ei katkestata automaatselt. Spekis mõiste: <em>detached fork</em></p>
</li>
<li>
<p><code>takeEvery('EVENT', generatorF)</code>- iga kord kui kutsutakse 'EVENT' pannaks käima generatorF, mitu saab korraga joosta.</p>
</li>
<li>
<p><code>takeLatest('EVENT', generatorF)</code>- iga kord kui kutsutakse 'EVENT' pannaks käima generatorF aga eelmised,
mis käima pandud, katkestatakse. Üks saab korraga koosta.</p>
</li>
<li>
<p><code>yield race({ [ key: string ]: saga })</code> - defineerib mitu sagat omavahel race konditsiooniga, et ühe käivitus katkestab teised</p>
<pre class="hljs"><code><div> takeEvery([
   <span class="hljs-string">'SET_ACTIVE_TAB'</span>
 ], <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">action</span>) </span>{
   <span class="hljs-keyword">yield</span> race({
     <span class="hljs-attr">task</span>: call(loadChartsOnTabLoad, action),
     <span class="hljs-attr">cancel1</span>: take(<span class="hljs-string">'TOKEN_CURRENT_FILTER_CHANGE_STARTED'</span>),
     <span class="hljs-attr">cancel2</span>: take(<span class="hljs-string">'TOKEN_BASE_FILTER_CHANGE_STARTED'</span>),
   });
 }),
</div></code></pre>
</li>
</ul>
<h1 id="hea-tava-arhitektuur">Hea tava arhitektuur</h1>
<ol>
<li>
<p>Eventid, mida kasutaja tegi, suunata alati läbi saga, anda selgelt prefixiga eristuv nimi ja mitte siduda otse
reduceriga et muuta storet. Näiteks : <code>'USER_CLICKED_BUTON'</code>. See on selleks, et teada kust poolt event tuli,
kas süsteemist või kasutaja intent. See teeb tihti järgmisele arendajal elu lihtsamaks, kes sama meetodit edasi
keerulisemaks arendab.</p>
</li>
<li>
<p>Ära dispatchi poolikuid state vaid kogu kokku kogu info mis vaja täis muudatuse tegemiseks ja siis tee lõpus üks
suur <code>batch()</code> mille sees on kõik muudatuste dispatchid. Sellisena ei pea sa muretsema kuidas rollbackida state seisu
kui saga generaator katkestatakse. Samuti vähendad rendereid ja poolikutest statedest tekkivaid vigu ja iffide rägastikku.</p>
</li>
</ol>
<p>Flow näide</p>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TB
  subgraph Generator-Saga
    takeLatest[takeLatest\nUSER_CLICKED_LOAD]

    takeLatest --> call1[call\nsetLoading]

    call1 --> call2[call\najax_fetch data1]
    call2 --> call3[call\najax_fetch data2]
    call3 --> call4[call\najax_fetch data3]

    call4 --> calculate[calculate sum: data1, data2, data3 ]

    calculate --> batchAll[put data1\nput data2\nput data3\nput sum\nsetReady]
  end
</div></code></pre>
<h1 id="lingid">Lingid</h1>
<ul>
<li>Redux-Saga õppematerjal - https://redux-saga.js.org/docs/introduction/GettingStarted/</li>
<li>function* -  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*</li>
</ul>

</body>
</html>
